/* tslint:disable */
/* eslint-disable */
/**
 * Algod REST API.
 * API endpoint for algod operations.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: contact@algorand.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AbortCatchup200Response,
  AddParticipationKey200Response,
  DebugSettingsProf,
  ErrorResponse,
  ParticipationKey,
  StartCatchup200Response,
} from '../models/index';
import {
    AbortCatchup200ResponseFromJSON,
    AbortCatchup200ResponseToJSON,
    AddParticipationKey200ResponseFromJSON,
    AddParticipationKey200ResponseToJSON,
    DebugSettingsProfFromJSON,
    DebugSettingsProfToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    ParticipationKeyFromJSON,
    ParticipationKeyToJSON,
    StartCatchup200ResponseFromJSON,
    StartCatchup200ResponseToJSON,
} from '../models/index';

export interface AbortCatchupRequest {
    catchpoint: string;
}

export interface AddParticipationKeyRequest {
    participationkey: Blob;
}

export interface AppendKeysRequest {
    participationId: string;
    keymap: Blob;
}

export interface DeleteParticipationKeyByIDRequest {
    participationId: string;
}

export interface GenerateParticipationKeysRequest {
    address: string;
    first: number;
    last: number;
    dilution?: number;
}

export interface GetParticipationKeyByIDRequest {
    participationId: string;
}

export interface ShutdownNodeRequest {
    timeout?: number;
}

export interface StartCatchupRequest {
    catchpoint: string;
    min?: number;
}

/**
 * 
 */
export class PrivateApi extends runtime.BaseAPI {

    /**
     * Given a catchpoint, it aborts catching up to this catchpoint
     * Aborts a catchpoint catchup.
     */
    async abortCatchupRaw(requestParameters: AbortCatchupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AbortCatchup200Response>> {
        if (requestParameters['catchpoint'] == null) {
            throw new runtime.RequiredError(
                'catchpoint',
                'Required parameter "catchpoint" was null or undefined when calling abortCatchup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/catchup/{catchpoint}`.replace(`{${"catchpoint"}}`, encodeURIComponent(String(requestParameters['catchpoint']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AbortCatchup200ResponseFromJSON(jsonValue));
    }

    /**
     * Given a catchpoint, it aborts catching up to this catchpoint
     * Aborts a catchpoint catchup.
     */
    async abortCatchup(requestParameters: AbortCatchupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AbortCatchup200Response> {
        const response = await this.abortCatchupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a participation key to the node
     */
    async addParticipationKeyRaw(requestParameters: AddParticipationKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddParticipationKey200Response>> {
        if (requestParameters['participationkey'] == null) {
            throw new runtime.RequiredError(
                'participationkey',
                'Required parameter "participationkey" was null or undefined when calling addParticipationKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/msgpack';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['participationkey'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddParticipationKey200ResponseFromJSON(jsonValue));
    }

    /**
     * Add a participation key to the node
     */
    async addParticipationKey(requestParameters: AddParticipationKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddParticipationKey200Response> {
        const response = await this.addParticipationKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * Append state proof keys to a participation key
     */
    async appendKeysRaw(requestParameters: AppendKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ParticipationKey>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling appendKeys().'
            );
        }

        if (requestParameters['keymap'] == null) {
            throw new runtime.RequiredError(
                'keymap',
                'Required parameter "keymap" was null or undefined when calling appendKeys().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/msgpack';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['keymap'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipationKeyFromJSON(jsonValue));
    }

    /**
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * Append state proof keys to a participation key
     */
    async appendKeys(requestParameters: AppendKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ParticipationKey> {
        const response = await this.appendKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     */
    async deleteParticipationKeyByIDRaw(requestParameters: DeleteParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling deleteParticipationKeyByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     */
    async deleteParticipationKeyByID(requestParameters: DeleteParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteParticipationKeyByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Generate and install participation keys to the node.
     */
    async generateParticipationKeysRaw(requestParameters: GenerateParticipationKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling generateParticipationKeys().'
            );
        }

        if (requestParameters['first'] == null) {
            throw new runtime.RequiredError(
                'first',
                'Required parameter "first" was null or undefined when calling generateParticipationKeys().'
            );
        }

        if (requestParameters['last'] == null) {
            throw new runtime.RequiredError(
                'last',
                'Required parameter "last" was null or undefined when calling generateParticipationKeys().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dilution'] != null) {
            queryParameters['dilution'] = requestParameters['dilution'];
        }

        if (requestParameters['first'] != null) {
            queryParameters['first'] = requestParameters['first'];
        }

        if (requestParameters['last'] != null) {
            queryParameters['last'] = requestParameters['last'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/generate/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate and install participation keys to the node.
     */
    async generateParticipationKeys(requestParameters: GenerateParticipationKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.generateParticipationKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the merged (defaults + overrides) config file in json.
     * Gets the merged config file.
     */
    async getConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/debug/settings/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns the merged (defaults + overrides) config file in json.
     * Gets the merged config file.
     */
    async getConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the current settings for blocking and mutex profiles
     */
    async getDebugSettingsProfRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DebugSettingsProf>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/debug/settings/pprof`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DebugSettingsProfFromJSON(jsonValue));
    }

    /**
     * Retrieves the current settings for blocking and mutex profiles
     */
    async getDebugSettingsProf(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DebugSettingsProf> {
        const response = await this.getDebugSettingsProfRaw(initOverrides);
        return await response.value();
    }

    /**
     * Given a participation ID, return information about that participation key
     * Get participation key info given a participation ID
     */
    async getParticipationKeyByIDRaw(requestParameters: GetParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ParticipationKey>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling getParticipationKeyByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipationKeyFromJSON(jsonValue));
    }

    /**
     * Given a participation ID, return information about that participation key
     * Get participation key info given a participation ID
     */
    async getParticipationKeyByID(requestParameters: GetParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ParticipationKey> {
        const response = await this.getParticipationKeyByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of participation keys
     * Return a list of participation keys
     */
    async getParticipationKeysRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ParticipationKey>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ParticipationKeyFromJSON));
    }

    /**
     * Return a list of participation keys
     * Return a list of participation keys
     */
    async getParticipationKeys(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ParticipationKey>> {
        const response = await this.getParticipationKeysRaw(initOverrides);
        return await response.value();
    }

    /**
     * Enables blocking and mutex profiles, and returns the old settings
     */
    async putDebugSettingsProfRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DebugSettingsProf>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/debug/settings/pprof`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DebugSettingsProfFromJSON(jsonValue));
    }

    /**
     * Enables blocking and mutex profiles, and returns the old settings
     */
    async putDebugSettingsProf(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DebugSettingsProf> {
        const response = await this.putDebugSettingsProfRaw(initOverrides);
        return await response.value();
    }

    /**
     * Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
     */
    async shutdownNodeRaw(requestParameters: ShutdownNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters['timeout'] != null) {
            queryParameters['timeout'] = requestParameters['timeout'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/shutdown`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
     */
    async shutdownNode(requestParameters: ShutdownNodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.shutdownNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a catchpoint, it starts catching up to this catchpoint
     * Starts a catchpoint catchup.
     */
    async startCatchupRaw(requestParameters: StartCatchupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartCatchup200Response>> {
        if (requestParameters['catchpoint'] == null) {
            throw new runtime.RequiredError(
                'catchpoint',
                'Required parameter "catchpoint" was null or undefined when calling startCatchup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['min'] != null) {
            queryParameters['min'] = requestParameters['min'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/catchup/{catchpoint}`.replace(`{${"catchpoint"}}`, encodeURIComponent(String(requestParameters['catchpoint']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartCatchup200ResponseFromJSON(jsonValue));
    }

    /**
     * Given a catchpoint, it starts catching up to this catchpoint
     * Starts a catchpoint catchup.
     */
    async startCatchup(requestParameters: StartCatchupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartCatchup200Response> {
        const response = await this.startCatchupRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
