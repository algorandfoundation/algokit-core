/* tslint:disable */
/* eslint-disable */
/**
 * Algod REST API.
 * API endpoint for algod operations.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: contact@algorand.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddParticipationKey200Response,
  ErrorResponse,
  GetPendingTransactionsByAddress200Response,
  ParticipationKey,
  PendingTransactionResponse,
  RawTransaction200Response,
} from '../models/index';
import {
    AddParticipationKey200ResponseFromJSON,
    AddParticipationKey200ResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GetPendingTransactionsByAddress200ResponseFromJSON,
    GetPendingTransactionsByAddress200ResponseToJSON,
    ParticipationKeyFromJSON,
    ParticipationKeyToJSON,
    PendingTransactionResponseFromJSON,
    PendingTransactionResponseToJSON,
    RawTransaction200ResponseFromJSON,
    RawTransaction200ResponseToJSON,
} from '../models/index';

export interface AddParticipationKeyRequest {
    participationkey: Blob;
}

export interface AppendKeysRequest {
    participationId: string;
    keymap: Blob;
}

export interface DeleteParticipationKeyByIDRequest {
    participationId: string;
}

export interface GenerateParticipationKeysRequest {
    address: string;
    first: number;
    last: number;
    dilution?: number;
}

export interface GetParticipationKeyByIDRequest {
    participationId: string;
}

export interface GetPendingTransactionsRequest {
    max?: number;
    format?: GetPendingTransactionsFormatEnum;
}

export interface GetPendingTransactionsByAddressRequest {
    address: string;
    max?: number;
    format?: GetPendingTransactionsByAddressFormatEnum;
}

export interface PendingTransactionInformationRequest {
    txid: string;
    format?: PendingTransactionInformationFormatEnum;
}

export interface RawTransactionRequest {
    rawtxn: Blob;
}

/**
 * 
 */
export class ParticipatingApi extends runtime.BaseAPI {

    /**
     * Add a participation key to the node
     */
    async addParticipationKeyRaw(requestParameters: AddParticipationKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddParticipationKey200Response>> {
        if (requestParameters['participationkey'] == null) {
            throw new runtime.RequiredError(
                'participationkey',
                'Required parameter "participationkey" was null or undefined when calling addParticipationKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/msgpack';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['participationkey'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddParticipationKey200ResponseFromJSON(jsonValue));
    }

    /**
     * Add a participation key to the node
     */
    async addParticipationKey(requestParameters: AddParticipationKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddParticipationKey200Response> {
        const response = await this.addParticipationKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * Append state proof keys to a participation key
     */
    async appendKeysRaw(requestParameters: AppendKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ParticipationKey>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling appendKeys().'
            );
        }

        if (requestParameters['keymap'] == null) {
            throw new runtime.RequiredError(
                'keymap',
                'Required parameter "keymap" was null or undefined when calling appendKeys().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/msgpack';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['keymap'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipationKeyFromJSON(jsonValue));
    }

    /**
     * Given a participation ID, append state proof keys to a particular set of participation keys
     * Append state proof keys to a participation key
     */
    async appendKeys(requestParameters: AppendKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ParticipationKey> {
        const response = await this.appendKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     */
    async deleteParticipationKeyByIDRaw(requestParameters: DeleteParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling deleteParticipationKeyByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a given participation key by ID
     * Delete a given participation key by ID
     */
    async deleteParticipationKeyByID(requestParameters: DeleteParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteParticipationKeyByIDRaw(requestParameters, initOverrides);
    }

    /**
     * Generate and install participation keys to the node.
     */
    async generateParticipationKeysRaw(requestParameters: GenerateParticipationKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling generateParticipationKeys().'
            );
        }

        if (requestParameters['first'] == null) {
            throw new runtime.RequiredError(
                'first',
                'Required parameter "first" was null or undefined when calling generateParticipationKeys().'
            );
        }

        if (requestParameters['last'] == null) {
            throw new runtime.RequiredError(
                'last',
                'Required parameter "last" was null or undefined when calling generateParticipationKeys().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dilution'] != null) {
            queryParameters['dilution'] = requestParameters['dilution'];
        }

        if (requestParameters['first'] != null) {
            queryParameters['first'] = requestParameters['first'];
        }

        if (requestParameters['last'] != null) {
            queryParameters['last'] = requestParameters['last'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/generate/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate and install participation keys to the node.
     */
    async generateParticipationKeys(requestParameters: GenerateParticipationKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.generateParticipationKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a participation ID, return information about that participation key
     * Get participation key info given a participation ID
     */
    async getParticipationKeyByIDRaw(requestParameters: GetParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ParticipationKey>> {
        if (requestParameters['participationId'] == null) {
            throw new runtime.RequiredError(
                'participationId',
                'Required parameter "participationId" was null or undefined when calling getParticipationKeyByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation/{participation-id}`.replace(`{${"participation-id"}}`, encodeURIComponent(String(requestParameters['participationId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipationKeyFromJSON(jsonValue));
    }

    /**
     * Given a participation ID, return information about that participation key
     * Get participation key info given a participation ID
     */
    async getParticipationKeyByID(requestParameters: GetParticipationKeyByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ParticipationKey> {
        const response = await this.getParticipationKeyByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of participation keys
     * Return a list of participation keys
     */
    async getParticipationKeysRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ParticipationKey>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/participation`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ParticipationKeyFromJSON));
    }

    /**
     * Return a list of participation keys
     * Return a list of participation keys
     */
    async getParticipationKeys(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ParticipationKey>> {
        const response = await this.getParticipationKeysRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions. 
     * Get a list of unconfirmed transactions currently in the transaction pool.
     */
    async getPendingTransactionsRaw(requestParameters: GetPendingTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPendingTransactionsByAddress200Response>> {
        const queryParameters: any = {};

        if (requestParameters['max'] != null) {
            queryParameters['max'] = requestParameters['max'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/transactions/pending`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetPendingTransactionsByAddress200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions. 
     * Get a list of unconfirmed transactions currently in the transaction pool.
     */
    async getPendingTransactions(requestParameters: GetPendingTransactionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPendingTransactionsByAddress200Response> {
        const response = await this.getPendingTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions. 
     * Get a list of unconfirmed transactions currently in the transaction pool by address.
     */
    async getPendingTransactionsByAddressRaw(requestParameters: GetPendingTransactionsByAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPendingTransactionsByAddress200Response>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling getPendingTransactionsByAddress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['max'] != null) {
            queryParameters['max'] = requestParameters['max'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/accounts/{address}/transactions/pending`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetPendingTransactionsByAddress200ResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions. 
     * Get a list of unconfirmed transactions currently in the transaction pool by address.
     */
    async getPendingTransactionsByAddress(requestParameters: GetPendingTransactionsByAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPendingTransactionsByAddress200Response> {
        const response = await this.getPendingTransactionsByAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed: - transaction committed (committed round > 0) - transaction still in the pool (committed round = 0, pool error = \"\") - transaction removed from pool due to error (committed round = 0, pool error != \"\") Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error. 
     * Get a specific pending transaction.
     */
    async pendingTransactionInformationRaw(requestParameters: PendingTransactionInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PendingTransactionResponse>> {
        if (requestParameters['txid'] == null) {
            throw new runtime.RequiredError(
                'txid',
                'Required parameter "txid" was null or undefined when calling pendingTransactionInformation().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/transactions/pending/{txid}`.replace(`{${"txid"}}`, encodeURIComponent(String(requestParameters['txid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PendingTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed: - transaction committed (committed round > 0) - transaction still in the pool (committed round = 0, pool error = \"\") - transaction removed from pool due to error (committed round = 0, pool error != \"\") Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error. 
     * Get a specific pending transaction.
     */
    async pendingTransactionInformation(requestParameters: PendingTransactionInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PendingTransactionResponse> {
        const response = await this.pendingTransactionInformationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Broadcasts a raw transaction or transaction group to the network.
     */
    async rawTransactionRaw(requestParameters: RawTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RawTransaction200Response>> {
        if (requestParameters['rawtxn'] == null) {
            throw new runtime.RequiredError(
                'rawtxn',
                'Required parameter "rawtxn" was null or undefined when calling rawTransaction().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-binary';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Algo-API-Token"] = await this.configuration.apiKey("X-Algo-API-Token"); // api_key authentication
        }

        const response = await this.request({
            path: `/v2/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['rawtxn'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RawTransaction200ResponseFromJSON(jsonValue));
    }

    /**
     * Broadcasts a raw transaction or transaction group to the network.
     */
    async rawTransaction(requestParameters: RawTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RawTransaction200Response> {
        const response = await this.rawTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetPendingTransactionsFormatEnum = {
    Json: 'json',
    Msgpack: 'msgpack'
} as const;
export type GetPendingTransactionsFormatEnum = typeof GetPendingTransactionsFormatEnum[keyof typeof GetPendingTransactionsFormatEnum];
/**
 * @export
 */
export const GetPendingTransactionsByAddressFormatEnum = {
    Json: 'json',
    Msgpack: 'msgpack'
} as const;
export type GetPendingTransactionsByAddressFormatEnum = typeof GetPendingTransactionsByAddressFormatEnum[keyof typeof GetPendingTransactionsByAddressFormatEnum];
/**
 * @export
 */
export const PendingTransactionInformationFormatEnum = {
    Json: 'json',
    Msgpack: 'msgpack'
} as const;
export type PendingTransactionInformationFormatEnum = typeof PendingTransactionInformationFormatEnum[keyof typeof PendingTransactionInformationFormatEnum];
