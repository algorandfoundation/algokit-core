# coding: utf-8

{{>partial_header}}

import pytest
import json
from pydantic import ValidationError

{{#models}}
{{#model}}
from {{modelPackage}}.{{classFilename}} import {{classname}}

{{^isEnum}}
@pytest.fixture
def {{classname|lower}}_data_minimal():
    """Fixture providing minimal data for {{classname}}."""
    return {
        {{#vars}}
        {{#required}}
        "{{baseName}}": {{{example}}}{{^example}}None{{/example}}{{^-last}},{{/-last}}
        {{/required}}
        {{/vars}}
    }

@pytest.fixture
def {{classname|lower}}_data_full():
    """Fixture providing complete data for {{classname}}."""
    return {
        {{#vars}}
        "{{baseName}}": {{{example}}}{{^example}}None{{/example}}{{^-last}},{{/-last}}
        {{/vars}}
    }
{{/isEnum}}

class Test{{classname}}:
    """{{classname}} test cases"""

{{^isEnum}}
    def test_{{classname}}_create_minimal(self, {{classname|lower}}_data_minimal):
        """Test {{classname}} creation with minimal data."""
        instance = {{classname}}(**{{classname|lower}}_data_minimal)
        {{#vars}}
        {{#required}}
        assert hasattr(instance, "{{name}}")
        {{/required}}
        {{/vars}}
        
    def test_{{classname}}_create_full(self, {{classname|lower}}_data_full):
        """Test {{classname}} creation with all fields."""
        instance = {{classname}}(**{{classname|lower}}_data_full)
        {{#vars}}
        assert hasattr(instance, "{{name}}")
        {{/vars}}
        
    def test_{{classname}}_to_dict(self, {{classname|lower}}_data_full):
        """Test {{classname}} serialization to dict."""
        instance = {{classname}}(**{{classname|lower}}_data_full)
        result = instance.to_dict()
        # Check that to_dict returns a dictionary
        assert isinstance(result, dict)
        # Check all fields are present in the serialized result
        {{#vars}}
        # Only check defined values - None values might be excluded
        if {{classname|lower}}_data_full.get("{{baseName}}") is not None:
            assert "{{baseName}}" in result
        {{/vars}}
        
    def test_{{classname}}_to_str(self, {{classname|lower}}_data_full):
        """Test {{classname}} string representation is JSON-compatible."""
        instance = {{classname}}(**{{classname|lower}}_data_full)
        string_repr = instance.to_json()
        # Verify the string representation can be parsed as JSON
        try:
            json.loads(string_repr)
            json_valid = True
        except:
            json_valid = False
        assert json_valid, "String representation should be valid JSON"
{{/isEnum}}
{{#isEnum}}
    def test_{{classname}}_values(self):
        """Test {{classname}} enum values."""
        # Verify each allowed value works
        {{#allowableValues}}
        {{#values}}
        assert {{classname}}({{{.}}}) is not None
        {{/values}}
        {{/allowableValues}}
        
    def test_{{classname}}_invalid_value(self):
        """Test {{classname}} with invalid enum value."""
        with pytest.raises(ValidationError):
            {{classname}}("invalid_value")
{{/isEnum}}
{{/model}}
{{/models}}
